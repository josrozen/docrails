Débuter avec Rails
==================

Ce guide est une prise en main de Ruby on Rails.  Après sa lecture, vous devriez être familier de :

* l'installation de Rails, la création d'une nouvelle application Rails, et la connexion de votre application à une base de données
* l'organisation générale d'une application Rails
* les principes de base de MVC (Modèle, Vue, Contrôleur) et du design RESTful TODO
* la génération rapide des pièces initiales d'une application Rails.



== Ce guide suppose

Ce guide est conçu pour les débutants qui veulent s'initier à la création d'une application Rails. Il ne suppose aucune expérience avec Rails. Cependant, pour en bénéficier, vous devez disposer des pré-requis suivants:

* le langage link:http://www.ruby-lang.org/en/downloads/[Ruby]
* le gestionnaire de paquet link:http://rubyforge.org/frs/?group_id=126[RubyGems]
* une installation opérationnelle de link:http://www.sqlite.org/[SQLite] (de préférence), link:http://www.mysql.com/[MySQL], ou link:http://www.postgresql.org/[PostgreSQL]

Il est fortement recommandé de *vous familiariser avec Ruby avant de vous lancer dans Rails*. Vous suivrez beaucoup plus facilement ce qui se passe dans une applicaiton Rails si vous comprenez la syntaxe Ruby de base. Rails ne va pas magiquement révolutionner la façon dont vous écrivez des applications Web si vous ne connaissez pas le langage qu'il utilise. Il y a de bonnes ressources gratuites en ligne pour apprendre Ruby, par exemple:

* link:http://www.humblelittlerubybook.com/[Mr. Neigborly’s Humble Little Ruby Book]
* link:http://www.rubycentral.com/book/[Programming Ruby]
* link:http://poignantguide.net/ruby/[Why's (Poignant) Guide to Ruby]

== Qu'est-ce que Rails?

Rails est un framework de développment d'applications web écrit avec le langage Ruby. Il est conçu pour faciliter la programmation d'applications web en faisant plusieurs assomptions sur ce dont tous les développeurs ont besoin pour démarrer. Il vous permet d'écrire moins de code pour accomplir plus qu'avec d'autres langages ou frameworks. Les développeur Rails expérimentés assurent également qu'il rend le développement d'applications web plus amusant.

Rails est un _logiciel opiniâtre_ (opinionated software). C'est à dire qu'il estime qu'il y a une meilleure façon de faire des choses et qu'il est conçu pour vous encourager à le faire ainsi (et dans certains cas décourage les alternatives). Si vous apprenez la "Voie de Rails" (Rails Way) vous augmenterez sans doute fantastiquement votre productivité. Si vous persistez à conserver vos habitudes, prises avec d'autres langages, en développant avec Rails, et essayez d'utiliser des patterns appris ailleurs, vous pourriez avoir une expérience moins agréable.

La philosophie de Rails comprend ces principes fondamentaux:

* DRY - "Don't Repeat Yourself" (Ne Vous Répétez pas) - suggère qu'écrire le même code à plusieurs reprises est une mauvaise chose.
* Convention Plutôt que Configuration (Convention Over Configuration) - signifie que Rails fait des assomptions sur ce que vous voulez faire et sur la façon de le faire, plutôt que de vous laisser ajuster tous les petits détails dans d'innombrables fichiers de configurations.
* REST est le meilleur pattern pour des applications web - organiser votre application autour de ressources et de verbes HTTP standards est la méthode la plus rapide.

=== L'architecture MVC

Rails est organisé autour de l'architecture modèle Modèle, Vue, Contrôleur, habituellement appelée simplement MVV. Les bénéfices de MVC comprennent:

* la séparation de la logique métier de l'interface utilisateur.
* la tendance naturelle à ne pas se répéter (DRY)
* l'évidence de l'emplacement des différents types de code pour une maintenance facilitée.   

==== Modèles
Un modèle représente l'information (les données) d'une application et les règles pour la manipuler. Dans le cas de Rails, les modèles sont d'abord utilisés pour gérer les interactions avec les tables dans une base de données. Le plus souvent une table dans votre base correspond à un modèle dans l'application. L'essentiel de la logique métier de votre application est concentré dans les modèles.

==== Vues

Les vues sont l'interface utilisateur de votre application. En Rails, les vues sont souvent des fichiers HTML contenant du code Ruby dédié à la présentation des données. Les vues ont la responsabilité de fournir des données au navigateur, ou aux autres outils utilisés pour faire des requêtes à votre application.

==== Contrôleurs

Les contrôleurs constituent la "colle" entre les modèles et les vues. En Rails les contrôleurs sont responsables du traitement des requètes entrantes en provenance du navigateur.

=== Les composants de Rails

Rails fournit une pile complète de composants pour créer des applications web, notamment:

* Action Controller
* Action View
* Active Record
* Action Mailer
* Active Resource
* Railties
* Active Support

==== Action Controller

Action Controller est le composant qui gère les contrôleurs dans une applicaion Rails. Le framework d'Action Controller framework traite les demandes entrantes, extrait les paramètres, et les affecte aux actions correspondantes. Les services fournis par Action Controller comprennent la gestion des sessions, le rendu des templates, et la gestion des redirections.

==== Action View

Action View gère les vues de votre applications Rails. Il peut générer HTML ou XML par défaut. Action View gère les templates de rendu, y compris ceux emboîtés (nested) ou partiels, et supporte nativement AJAX.

==== Active Record

Active Record est la base des modèles des applications Rails. Il permet une indépendance par rapport aux bases de données, fournit les fonctionnalités de base CRUD, des capacités avancées de recherche, et la capacité de relier les modèles les uns aux autres, entre autres services.

==== Action Mailer

Action Mailer est un framework pour construire des services de messagerie. Action Mailer permet d'envoyer des emails basés sur des templates flexibles, ou de recevoir et de traiter des emails entrants.

==== Active Resource

Active Resource fournit un framework pour gérer la connexion entre des objects métiers et des services web RESTful. Il implémente une façon de relier des ressources web à des objets locaux avec une sémantique CRUD.

==== Railties

Railties est le noyau (core) de code de Rails qui construit toutes les applications Rails en assemblant les différents frameworks.

==== Active Support

Active Support est un vaste ensemble de classes utilitaires et d'extensions à la bibliothèque standard de Ruby qui sont utilisés en Rails, tant par le noyau que vos applications. 

=== REST

Le fondement de l'architecture RESTful est généralement considéré être la thèse doctorale de Roy Fielding, link:http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm[Architectural Styles and the Design of Network-based Software Architectures]. Heureusement, vous n'avez pas vraiment besoin de lire l'intégralité de ce document pour comprendre comment REST fonctionne dans Rails. REST, acronyme de Representational State Transfer, se réduit à deux principes pour notre propos:

* l'utilisation d'identificateurs de ressources (que, dans le cadre de ce document, vous pouvez considérer être des URLs) pour représenter des ressources
* le transfert de représentations de l'état de cette ressource entre composants d'un système. 

Par exemple, pour une application Rails une requète telle que:

+DELETE /photos/17+

serait comprise comme la référence d'une ressource photo avec l'ID 17, et l'indication d'une action désirée (la suppression de cette ressource). REST est un style naturelle pour l'architecture d'application web, et Rails le rend encore plus naturel grâce à ses conventions qui vous isole de certaines complexités de l'architecture RESTful.

Si vous souhaitez plus de détails sur le style architectural REST, ces ressources sont plus accessibles que la thèse de Fielding:

* link:http://www.infoq.com/articles/rest-introduction[A Brief Introduction to REST] par Stefan Tilkov
* link:http://bitworking.org/news/373/An-Introduction-to-REST[An Introduction to REST] (didacticiel vidéo) par Joe Gregorio
* link:http://en.wikipedia.org/wiki/Representational_State_Transfer[Representational State Transfer] article Wikipedia

== Création d'un nouveau projet Rails

En suivant ce guide, vous créerez un projet Rails appelé +blog+, un weblog (très) simple. Avant de pouvoir construire l'application, vous devez vérifier que Rails est bien installé.

=== Installation de Rails

Le plus souvent, la façon la plus simple d'installer Rails est d'utiliser RubyGems:

[source, shell]
-------------------------------------------------------
$ gem install rails
-------------------------------------------------------

NOTE: Des circonstances particulières pourraient vous faire préférer des méthodes alternatives:

* Si vous travaillez sous Windows, vous trouvez peut-être plus simple d'installer  link:http://instantrails.rubyforge.org/wiki/wiki.pl[Instant Rails]. Soyez cependant conscient qu'Instant Rails tends à prendre du retard par rapport à la version courante de Rails. Vous remarquerez aussi que le développement Rails sous Windows est une expérience généralement moins satisfaisante qu'avec d'autres systèmes d'exploitation. Si cela est possible, nous vous suggérons l'installation d'une machine Linux virtuelle et son utilisation pour vos développements, plutôt que directement Windows.
* Si vous souhaitez rester sur le fil des changements du framework Rails, vous préférerez cloner le  link:http://github.com/rails/rails/tree/master[code source] depuis github. Ceci dit, ce n'est pas une option recommandée pour les débutants.

=== Création de l'application Blog

Ouvrez une console, naviguez jusque dans votre répertoire, où vous devez avoir le droit de créer des fichiers, et tapez:

[source, shell]
-------------------------------------------------------
$ rails blog
-------------------------------------------------------

Cela va créer une application Rails qui utilise une base SQLite pour le stockage des données. Si vous préférez utilisez MySQL, utilisez plutôt cette commande :

[source, shell]
-------------------------------------------------------
$ rails blog -d mysql
-------------------------------------------------------

Ou encore, si c'est PostgreSQL qui stocke vos données, cette commande :

[source, shell]
-------------------------------------------------------
$ rails blog -d postgresql
-------------------------------------------------------

Après la création de l'application blog, naviguez dans son répertoire et continuez à travailler directement dans cette application :

[source, shell]
-------------------------------------------------------
$ cd blog
-------------------------------------------------------

Rails crée en effet un répertoire dans votre répertoire de travail avec le nom +blog+. Ouvrez ce répertoire et explorez sont conteny. LA plupart du travail dans ce guide se déroulera dans répertoire +app/+, mais voici une présentation succinte de chacun des répertoires que Rails crée dans une nouvelle application:

[options="header"]
|==========================================================================================================
|Fichier/Répertoire |Présentation
|+README+		|Un manuel pour votre application. Utilisez pour indiquez à d'autres ce que votre application fait, comment la configurer, etc...
|+Rakefile+	|Ce fichier contient des travaux batchs qui peuvent être exécutés en mode console.
|+app/+		|Contient les contrôleurs, modèles, et les vues de votre application. Ce sera votre principal centre d'intérêt pour le reste de ce guide.
|+config/+		|Configure les règles d'exécution de votre application, les routes, les bases, ...
|+db/+			|Contient le schéma de votre base, ainsi que les migrations. Vous allez découvrir les migrations très prochainement.
|+doc/+		|Documentation en profondeur de votre application.
|+lib/+		|Modules étendus de votre application (non couverts par ce guide).
|+log/+		|Fichiers de log.
|+public/+		|Le seul répertoire vu tel quel. C'est là que vos images, votre javascript, vos feuilles de style (CSS) et d'autres fichiers statiques doivent se trouver.
|+script/+		|Scripts fournis par Rails pour des tâches récurrentes : benchmarking, installation de plugin, ainsi que le démarrage de la console ou du serveur web.
|+test/+		|Tests unitaires, fixtures, et apparatus de test. Ce sujet est traité dans link:../testing_rails_applications.html[Le test des Applications Rails]
|+tmp/+		|Fichiers temporaires
|+vendor/+		|Destiné au code complémentaire. Dans une application Rails typique, cela comprend Ruby Gems, le code source de Rails (si vous l'installez dans votre projet) et les plugins contenant des fonctionnalités additionnelles packagées.
|==========================================================================================================

=== Configuration de la base de données

Presque toutes les applications Rails interagissent avec une base de données ; la base utilisée est spécifiée dans un fichier de configuration, +config/database.yml+.
Si vous ouvrez ce fichier pour une application qui vient d'être générée, vous voyez une configuration de base de données par défaut pour SQLite. Ce fichier contient de sections pour 3 différents environnements d'exécution pour Rails:

* L'environnement +développement+ est utilisé sur votre machine de développement où vous interagissez directement avec l'application
* L'environnment +test+ est utilisé pour exécuter les tests automatisés
* L'environnement +production+ est utilisé pour déployer votre application pour son accès par le reste du monde.

==== Configuration d'une base de données SQLite

Rails supporte nativement link:http://www.sqlite.org/[SQLite], qui est un gestionnaire de base de données légère sans besoin de serveur. Si un environnement de production peut surcharger SQLite, il suffit pour le développement et les tests. Rails utilise par défaut une base de données SQLite à la création d'un nouveau projet, mais vous pouvez toujours le changer plus tard.

Voici la section d'un fichier de configuration par défaut avec les informations de connexion pour l'environnement de développement:

[source, ruby]
-------------------------------------------------------
development:
  adapter: sqlite3
  database: db/development.sqlite3
  timeout: 5000
-------------------------------------------------------

Si vous n'avez pas de moteur de base de données installées, SQLite est le plus simple à installer. Si vous utilisez OS X 10.5+ sur un Mac vous l'avez déjà. Sinon vous pouvez l'installer avec RubyGems. 

Si vous n'utilisez pas OS X 10.5+ vous devez installer la gem SQLite.  De la même façon que pour Rails il vous suffit de taper:

[source, shell]
-------------------------------------------------------
$ gem install sqlite3-ruby
-------------------------------------------------------

==== Configuration d'une base de données MySQL

Si vous choisissez MySQL, votre +config/database.yml+ sera un peu différent. Voici la section pour l'environnement de développement:

[source, ruby]
-------------------------------------------------------
development:
  adapter: mysql
  encoding: utf8
  database: blog_development
  username: root
  password:
  socket: /tmp/mysql.sock
-------------------------------------------------------
Si l'installation de MySQL sur votre machine de développement a un utilisateur root sans password, cette configuration vous convient. Sinon, changez l'utilisateur et le password dans cette section +development+.

==== Configuration d'une base de données PostgreSQL

Si vous choisissez PostgreSQL, votre +config/database.yml+ sera adaptée pour l'utiliser :

[source, ruby]
-------------------------------------------------------
development:
  adapter: postgresql
  encoding: unicode
  database: blog_development
  username: blog
  password:
-------------------------------------------------------

Changez l'utilisateur et le password dans cette section +development+ si nécessaire.

==== Création de la base de données

Maintenant que vous avez configuré la base de données, Il vous faut demander à Rails de créer une base vide pour vous. Vous pouvez faire cela en exécutant une commande rake:

[source, shell]
-------------------------------------------------------
$ rake db:create
-------------------------------------------------------

== Hello, Rails!

One of the traditional places to start with a new language is by getting some text up on screen quickly. To do that in Rails, you need to create at minimum a controller and a view. Fortunately, you can do that in a single command. Enter this command in your terminal:

[source, shell]
-------------------------------------------------------
$ script/generate controller home index
-------------------------------------------------------

TIP: If you're on Windows, or your Ruby is set up in some non-standard fashion, you may need to explicitly pass Rails +script+ commands to Ruby: +ruby script/generate controller home index+.

Rails will create several files for you, including +app/views/home/index.html.erb+. This is the template that will be used to display the results of the +index+ action (method) in the +home+ controller. Open this file in your text editor and edit it to contain a single line of code:

[source, html]
-------------------------------------------------------
<h1>Hello, Rails!</h1>
-------------------------------------------------------

=== Starting up the Web Server

You actually have a functional Rails application already - after running only two commands! To see it, you need to start a web server on your development machine. You can do this by running another command:

[source, shell]
-------------------------------------------------------
$ script/server
-------------------------------------------------------

This will fire up the lightweight Webrick web server by default. To see your application in action, open a browser window and navigate to +http://localhost:3000+. You should see Rails' default information page:

image:images/rails_welcome.png[Welcome Aboard screenshot]

TIP: To stop the web server, hit Ctrl+C in the terminal window where it's running. In development mode, Rails does not generally require you to stop the server; changes you make in files will be automatically picked up by the server.

The "Welcome Aboard" page is the smoke test for a new Rails application: it makes sure that you have your software configured correctly enough to serve a page. To view the page you just created, navigate to +http://localhost:3000/home/index+.

=== Setting the Application Home Page

You'd probably like to replace the "Welcome Aboard" page with your own application's home page. The first step to doing this is to delete the default page from your application:

[source, shell]
-------------------------------------------------------
$ rm public/index.html
-------------------------------------------------------

Now, you have to tell Rails where your actual home page is located. Open the file +config/routes.rb+ in your editor. This is your application's, _routing file_, which holds entries in a special DSL (domain-specific language) that tells Rails how to connect incoming requests to controllers and actions. At the bottom of the file you'll see the _default routes_:

[source, ruby]
-------------------------------------------------------
map.connect ':controller/:action/:id'
map.connect ':controller/:action/:id.:format'
-------------------------------------------------------

The default routes handle simple requests such as +/home/index+: Rails translates that into a call to the +index+ action in the +home+ controller. As another example, +/posts/edit/1+ would run the +edit+ action in the +posts+ controller with an +id+ of 1.

To hook up your home page, you need to add another line to the routing file, above the default routes:

[source, ruby]
-------------------------------------------------------
map.root :controller => "home"
-------------------------------------------------------

This line illustrates one tiny bit of the "convention over configuration" approach: if you don't specify an action, Rails assumes the +index+ action.

Now if you navigate to +http://localhost:3000+ in your browser, you'll see the +home/index+ view.

NOTE: For more information about routing, refer to link:../routing_outside_in.html[Rails Routing from the Outside In].

== Getting Up and Running Quickly With Scaffolding

Rails _scaffolding_ is a quick way to generate some of the major pieces of an application. If you want to create the models, views, and controllers for a new resource in a single operation, scaffolding is the tool for the job. 

== Creating a Resource

In the case of the blog application, you can start by generating a scaffolded Post resource: this will represent a single blog posting. To do this, enter this command in your terminal:

[source, shell]
-------------------------------------------------------
$ script/generate scaffold Post name:string title:string content:text
-------------------------------------------------------

NOTE: While scaffolding will get you up and running quickly, the "one size fits all" code that it generates is unlikely to be a perfect fit for your application. In most cases, you'll need to customize the generated code. Many experienced Rails developers avoid scaffolding entirely, preferring to write all or most of their source code from scratch.

The scaffold generator will build 13 files in your application, along with some folders, and edit one more. Here's a quick overview of what it creates:

[options="header"]
|==========================================================================================================
|File                                          |Purpose
|app/models/post.rb                            |The Post model
|db/migrate/20081013124235_create_posts.rb     |Migration to create the posts table in your database (your name will include a different timestamp)
|app/views/posts/index.html.erb                |A view to display an index of all posts 
|app/views/posts/show.html.erb                 |A view to display a single post
|app/views/posts/new.html.erb                  |A view to create a new post
|app/views/posts/edit.html.erb                 |A view to edit an existing post
|app/views/layouts/posts.html.erb              |A view to control the overall look and feel of the other posts views
|public/stylesheets/scaffold.css               |Cascading style sheet to make the scaffolded views look better
|app/controllers/posts_controller.rb           |The Posts controller
|test/functional/posts_controller_test.rb      |Functional testing harness for the posts controller
|app/helpers/posts_helper.rb                   |Helper functions to be used from the posts views
|config/routes.rb                              |Edited to include routing information for posts
|test/fixtures/posts.yml                       |Dummy posts for use in testing
|test/unit/post_test.rb                        |Unit testing harness for the posts model
|==========================================================================================================

=== Running a Migration

One of the products of the +script/generate scaffold+ command is a _database migration_. Migrations are Ruby classes that are designed to make it simple to create and modify database tables. Rails uses rake commands to run migrations, and it's possible to undo a migration after it's been applied to your database. Migration filenames include a timestamp to ensure that they're processed in the order that they were created.

If you look in the +db/migrate/20081013124235_create_posts.rb+ file (remember, yours will have a slightly different name), here's what you'll find:

[source, ruby]
-------------------------------------------------------
class CreatePosts < ActiveRecord::Migration
  def self.up
    create_table :posts do |t|
      t.string :name
      t.string :title
      t.text :content

      t.timestamps
    end
  end

  def self.down
    drop_table :posts
  end
end
-------------------------------------------------------

If you were to translate that into words, it says something like: when this migration is run, create a table named +posts+ with two string columns (+name+ and +title+) and a text column (+content+), and generate timestamp fields to track record creation and updating. You can learn the detailed syntax for migrations in the link:../migrations.html[Rails Database Migrations] guide.

At this point, you can use a rake command to run the migration:

[source, shell]
-------------------------------------------------------
$ rake db:create
$ rake db:migrate
-------------------------------------------------------

NOTE: Because you're working in the development environment by default, this command will apply to the database defined in the +development+ section of your +config/database.yml+ file.

=== Adding a Link

To hook the posts up to the home page you've already created, you can add a link to the home page. Open +/app/views/home/index.html.erb+ and modify it as follows:

[source, ruby]
-------------------------------------------------------
<h1>Hello, Rails!</h1>

<%= link_to "My Blog", posts_path %>
-------------------------------------------------------

The +link_to+ method is one of Rails' built-in view helpers. It creates a hyperlink based on text to display and where to go - in this case, to the path for posts.

=== Working with Posts in the Browser

Now you're ready to start working with posts. To do that, navigate to +http://localhost:3000+ and then click the "My Blog" link:

image:images/posts_index.png[Posts Index screenshot]

This is the result of Rails rendering the +index+ view of your posts. There aren't currently any posts in the database, but if you click the +New Post+ link you can create one. After that, you'll find that you can edit posts, look at their details, or destroy them. All of the logic and HTML to handle this was built by the single +script/generate scaffold+ command.

TIP: In development mode (which is what you're working in by default), Rails reloads your application with every browser request, so there's no need to stop and restart the web server.

Congratulations, you're riding the rails! Now it's time to see how it all works.

=== The Model

The model file, +app/models/post.rb+ is about as simple as it can get:

[source, ruby]
-------------------------------------------------------
class Post < ActiveRecord::Base
end
-------------------------------------------------------

There isn't much to this file - but note that the +Post+ class inherits from +ActiveRecord::Base+. Active Record supplies a great deal of functionality to your Rails models for free, including basic database CRUD (Create, Read, Update, Destroy) operations, data validation, as well as sophisticated search support and the ability to relate multiple models to one another.

=== Adding Some Validation

Rails includes methods to help you validate the data that you send to models. Open the +app/models/post.rb+ file and edit it:

[source, ruby]
-------------------------------------------------------
class Post < ActiveRecord::Base
  validates_presence_of :name, :title
  validates_length_of :title, :minimum => 5
end
-------------------------------------------------------

These changes will ensure that all posts have a name and a title, and that the title is at least five characters long. Rails can validate a variety of conditions in a model, including the presence or uniqueness of columns, their format, and the existence of associated objects.

=== Using the Console

To see your validations in action, you can use the console. The console is a command-line tool that lets you execute Ruby code in the context of your application:

[source, shell]
-------------------------------------------------------
$ script/console
-------------------------------------------------------

After the console loads, you can use it to work with your application's models:

[source, shell]
-------------------------------------------------------
>> p = Post.create(:content => "A new post")
=> #<Post id: nil, name: nil, title: nil, content: "A new post", 
created_at: nil, updated_at: nil>
>> p.save
=> false
>> p.errors
=> #<ActiveRecord::Errors:0x23bcf0c @base=#<Post id: nil, name: nil, 
title: nil, content: "A new post", created_at: nil, updated_at: nil>, 
@errors={"name"=>["can't be blank"], "title"=>["can't be blank", 
"is too short (minimum is 5 characters)"]}>
-------------------------------------------------------

This code shows creating a new +Post+ instance, attempting to save it and getting +false+ for a return value (indicating that the save failed), and inspecting the +errors+ of the post.

TIP: Unlike the development web server, the console does not automatically load your code afresh for each line. If you make changes, type +reload!+ at the console prompt to load them.

=== Listing All Posts

The easiest place to start looking at functionality is with the code that lists all posts. Open the file +app/controllers/posts_controller.rb + and look at the +index+ action:

[source, ruby]
-------------------------------------------------------
def index
  @posts = Post.find(:all)

  respond_to do |format|
    format.html # index.html.erb
    format.xml  { render :xml => @posts }
  end
end
-------------------------------------------------------

This code sets the +@posts+ instance variable to an array of all posts in the database. +Post.find(:all)+ or +Post.all+ calls the +Post+ model to return all of the posts that are currently in the database, with no limiting conditions.

TIP: For more information on finding records with Active Record, see link:../finders.html[Active Record Finders].

The +respond_to+ block handles both HTML and XML calls to this action. If you browse to +http://localhost:3000/posts.xml+, you'll see all of the posts in XML format. The HTML format looks for a view in +app/views/posts/+ with a name that corresponds to the action name. Rails makes all of the instance variables from the action available to the view. Here's +app/view/posts/index.html.erb+:

[source, ruby]
-------------------------------------------------------
<h1>Listing posts</h1>

<table>
  <tr>
    <th>Name</th>
    <th>Title</th>
    <th>Content</th>
  </tr>

<% for post in @posts %>
  <tr>
    <td><%=h post.name %></td>
    <td><%=h post.title %></td>
    <td><%=h post.content %></td>
    <td><%= link_to 'Show', post %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
    <td><%= link_to 'Destroy', post, :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New post', new_post_path %>
-------------------------------------------------------

This view iterates over the contents of the +@posts+ array to display content and links. A few things to note in the view:

* +h+ is a Rails helper method to sanitize displayed data, preventing cross-site scripting attacks
* +link_to+ builds a hyperlink to a particular destination
* +edit_post_path+ is a helper that Rails provides as part of RESTful routing. You’ll see a variety of these helpers for the different actions that the controller includes.

TIP: For more details on the rendering process, see link:../layouts_and_rendering.html[Layouts and Rendering in Rails].

=== Customizing the Layout

The view is only part of the story of how HTML is displayed in your web browser. Rails also has the concept of +layouts+, which are containers for views. When Rails renders a view to the browser, it does so by putting the view's HTML into a layout's HTML. The +script/generate scaffold+ command automatically created a default layout, +app/views/layouts/posts.html.erb+, for the posts. Open this layout in your editor and modify the +body+ tag:

[source, ruby]
-------------------------------------------------------
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <title>Posts: <%= controller.action_name %></title>
  <%= stylesheet_link_tag 'scaffold' %>
</head>
<body style="background: #EEEEEE;">

<p style="color: green"><%= flash[:notice] %></p>

<%= yield  %>

</body>
</html>
-------------------------------------------------------

Now when you refresh the +/posts+ page, you'll see a gray background to the page. This same gray background will be used throughout all the views for posts.

=== Creating New Posts

Creating a new post involves two actions. The first is the +new+ action, which instantiates an empty +Post+ object:

[source, ruby]
-------------------------------------------------------
def new
  @post = Post.new

  respond_to do |format|
    format.html # new.html.erb
    format.xml  { render :xml => @post }
  end
end
-------------------------------------------------------

The +new.html.erb+ view displays this empty Post to the user:

[source, ruby]
-------------------------------------------------------
<h1>New post</h1>

<% form_for(@post) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </p>
  <p>
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </p>
  <p>
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </p>
  <p>
    <%= f.submit "Create" %>
  </p>
<% end %>

<%= link_to 'Back', posts_path %>
-------------------------------------------------------

The +form_for+ block is used to create an HTML form. Within this block, you have access to methods to build various controls on the form. For example, +f.text_field :name+ tells Rails to create a text input on the form, and to hook it up to the +name+ attribute of the instance being displayed. You can only use these methods with attributes of the model that the form is based on (in this case +name+, +title+, and +content+). Rails uses +form_for+ in preference to having your write raw HTML because the code is more succinct, and because it explicitly ties the form to a particular model instance.

TIP: If you need to create an HTML form that displays arbitrary fields, not tied to a model, you should use the +form_tag+ method, which provides shortcuts for building forms that are not necessarily tied to a model instance.

When the user clicks the +Create+ button on this form, the browser will send information back to the +create+ method of the controller (Rails knows to call the +create+ method because the form is sent with an HTTP POST request; that's one of the conventions that I mentioned earlier):

[source, ruby]
-------------------------------------------------------
def create
  @post = Post.new(params[:post])

  respond_to do |format|
    if @post.save
      flash[:notice] = 'Post was successfully created.'
      format.html { redirect_to(@post) }
      format.xml  { render :xml => @post, :status => :created, :location => @post }
    else
      format.html { render :action => "new" }
      format.xml  { render :xml => @post.errors, :status => :unprocessable_entity }
    end
  end
end
-------------------------------------------------------

The +create+ action instantiates a new Post object from the data supplied by the user on the form, which Rails makes available in the +params+ hash. After saving the new post, it uses +flash[:notice]+ to create an informational message for the user, and redirects to the show action for the post. If there's any problem, the +create+ action just shows the +new+ view a second time, with any error messages.

Rails provides the +flash+ hash (usually just called the Flash) so that messages can be carried over to another action, providing the user with useful information on the status of their request.  In the case of +create+, the user never actually sees any page rendered during the Post creation process, because it immediately redirects to the new Post as soon Rails saves the record. The Flash carries over a message to the next action, so that when the user is redirected back to the +show+ action, they are presented with a message saying "Post was successfully created."

=== Showing an Individual Post

When you click the +show+ link for a post on the index page, it will bring you to a URL like +http://localhost:3000/posts/1+. Rails interprets this as a call to the +show+ action for the resource, and passes in +1+ as the +:id+ parameter. Here's the +show+ action:

[source, ruby]
-------------------------------------------------------
def show
  @post = Post.find(params[:id])

  respond_to do |format|
    format.html # show.html.erb
    format.xml  { render :xml => @post }
  end
end
-------------------------------------------------------

The +show+ action uses +Post.find+ to search for a single record in the database by its id value. After finding the record, Rails displays it by using +show.html.erb+:

[source, ruby]
-------------------------------------------------------
<p>
  <b>Name:</b>
  <%=h @post.name %>
</p>

<p>
  <b>Title:</b>
  <%=h @post.title %>
</p>

<p>
  <b>Content:</b>
  <%=h @post.content %>
</p>


<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
-------------------------------------------------------

=== Editing Posts

Like creating a new post, editing a post is a two-part process. The first step is a request to +edit_post_path(@post)+ with a particular post. This calls the +edit+ action in the controller:

[source, ruby]
-------------------------------------------------------
def edit
  @post = Post.find(params[:id])
end
-------------------------------------------------------

After finding the requested post, Rails uses the +edit.html.erb+ view to display it:

[source, ruby]
-------------------------------------------------------
<h1>Editing post</h1>

<% form_for(@post) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </p>
  <p>
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </p>
  <p>
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </p>
  <p>
    <%= f.submit "Update" %>
  </p>
<% end %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
-------------------------------------------------------

Submitting the form created by this view will invoke the +update+ action within the controller:

[source, ruby]
-------------------------------------------------------
def update
  @post = Post.find(params[:id])

  respond_to do |format|
    if @post.update_attributes(params[:post])
      flash[:notice] = 'Post was successfully updated.'
      format.html { redirect_to(@post) }
      format.xml  { head :ok }
    else
      format.html { render :action => "edit" }
      format.xml  { render :xml => @post.errors, :status => :unprocessable_entity }
    end
  end
end
-------------------------------------------------------

In the +update+ action, Rails first uses the +:id+ parameter passed back from the edit view to locate the database record that's being edited. The +update_attributes+ call then takes the rest of the parameters from the request and applies them to this record. If all goes well, the user is redirected to the post's +show+ view. If there are any problems, it's back to +edit+ to correct them.

NOTE: Sharp-eyed readers will have noticed that the +form_for+ declaration is identical for the +new+ and +edit+ views. Rails generates different code for the two forms because it's smart enough to notice that in the one case it's being passed a new record that has never been saved, and in the other case an existing record that has already been saved to the database. In a production Rails application, you would ordinarily eliminate this duplication by moving identical code to a _partial template_, which you could then include in both parent templates. But the scaffold generator tries not to make too many assumptions, and generates code that’s easy to modify if you want different forms for +create+ and +edit+.

=== Destroying a Post

Finally, clicking one of the +destroy+ links sends the associated id to the +destroy+ action:

[source, ruby]
-------------------------------------------------------
def destroy
  @post = Post.find(params[:id])
  @post.destroy

  respond_to do |format|
    format.html { redirect_to(posts_url) }
    format.xml  { head :ok }
  end
end
-------------------------------------------------------

The +destroy+ method of an Active Record model instance removes the corresponding record from the database. After that's done, there isn't any record to display, so Rails redirects the user's browser to the index view for the model.

== DRYing up the Code

At this point, it’s worth looking at some of the tools that Rails provides to eliminate duplication in your code. In particular, you can use _partials_ to clean up duplication in views and _filters_ to help with duplication in controllers.

=== Using Partials to Eliminate View Duplication

As you saw earlier, the scaffold-generated views for the +new+ and +edit+ actions are largely identical. You can pull the shared code out into a +partial+ template. This requires editing the new and edit views, and adding a new template. The new +_form.html.erb+ template should be saved in the same +app/views/posts+ folder as the files from which it is being extracted:

+new.html.erb+:

[source, ruby]
-------------------------------------------------------
<h1>New post</h1>

<%= render :partial => "form" %>

<%= link_to 'Back', posts_path %>
-------------------------------------------------------

+edit.html.erb+:

[source, ruby]
-------------------------------------------------------
<h1>Editing post</h1>

<%= render :partial => "form" %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
-------------------------------------------------------

+_form.html.erb+:

[source, ruby]
-------------------------------------------------------
<% form_for(@post) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </p>
  <p>
    <%= f.label :title, "title" %><br />
    <%= f.text_field :title %>
  </p>
  <p>
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </p>
  <p>
    <%= f.submit "Save" %>
  </p>
<% end %>
-------------------------------------------------------

Now, when Rails renders the +new+ or +edit+ view, it will insert the +_form+ partial at the indicated point. Note the naming convention for partials: if you refer to a partial named +form+ inside of a view, the corresponding file is +_form.html.erb+, with a leading underscore.

For more information on partials, refer to the link:../layouts_and_rendering.html[Layouts and Rending in Rails] guide.

=== Using Filters to Eliminate Controller Duplication

At this point, if you look at the controller for posts, you’ll see some duplication:

[source, ruby]
-------------------------------------------------------
class PostsController < ApplicationController
  # ...
  def show
    @post = Post.find(params[:id])
	# ... 
  end

  def edit
    @post = Post.find(params[:id])
  end

  def update
    @post = Post.find(params[:id])
    # ...
  end

  def destroy
    @post = Post.find(params[:id])
    # ...
  end
end
-------------------------------------------------------

Four instances of the exact same line of code doesn’t seem very DRY. Rails provides _filters_ as a way to address this sort of repeated code. In this case, you can DRY things up by using a +before_filter+:

[source, ruby]
-------------------------------------------------------
class PostsController < ApplicationController
  before_filter :find_post, :only => [:show, :edit, :update, :destroy]
  # ...
  def show
	# ... 
  end

  def edit
  end

  def update
    # ...
  end

  def destroy
    # ...
  end

  private
    def find_post
      @post = Post.find(params[:id])
    end
end
-------------------------------------------------------

Rails runs _before filters_ before any action in the controller. You can use the +:only+ clause to limit a before filter to only certain actions, or an +:except+ clause to specifically skip a before filter for certain actions. Rails also allows you to define _after filters_ that run after processing an action, as well as _around filters_ that surround the processing of actions. Filters can also be defined in external classes to make it easy to share them between controllers.

For more information on filters, see the link:actioncontroller_basics.html[Action Controller Basics] guide.

== Adding a Second Model

Now that you've seen what's in a model built with scaffolding, it's time to add a second model to the application. The second model will handle comments on blog posts.

=== Generating a Model 

Models in Rails use a singular name, and their corresponding database tables use a plural name. For the model to hold comments, the convention is to use the name Comment. Even if you don't want to use the entire apparatus set up by scaffolding, most Rails developers still use generators to make things like models and controllers. To create the new model, run this command in your terminal:

[source, shell]
-------------------------------------------------------
$ script/generate model Comment commenter:string body:text post:references
-------------------------------------------------------

This command will generate four files:

* +app/models/comment.rb+ - The model
* +db/migrate/20081013214407_create_comments.rb - The migration
* +test/unit/comment_test.rb+ and +test/fixtures/comments.yml+ - The test harness.

First, take a look at +comment.rb+:

[source, ruby]
-------------------------------------------------------
class Comment < ActiveRecord::Base
  belongs_to :post
end
-------------------------------------------------------

This is very similar to the +post.rb+ model that you saw earlier. The difference is the line +belongs_to :post+, which sets up an Active Record _association_. You'll learn a little about associations in the next section of this guide.

In addition to the model, Rails has also made a migration to create the corresponding database table:

[source, ruby]
-------------------------------------------------------
class CreateComments < ActiveRecord::Migration
  def self.up
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end
  end

  def self.down
    drop_table :comments
  end
end
-------------------------------------------------------

The +t.references+ line sets up a foreign key column for the association between the two models. Go ahead and run the migration:

[source, shell]
-------------------------------------------------------
$ rake db:migrate
-------------------------------------------------------

Rails is smart enough to only execute the migrations that have not already been run against this particular database.

=== Associating Models

Active Record associations let you easily declare the relationship between two models. In the case of comments and posts, you could write out the relationships this way:

* Each comment belongs to one post
* One post can have many comments

In fact, this is very close to the syntax that Rails uses to declare this association. You've already seen the line of code inside the Comment model that makes each comment belong to a Post:

[source, ruby]
-------------------------------------------------------
class Comment < ActiveRecord::Base
  belongs_to :post
end
-------------------------------------------------------

You'll need to edit the +post.rb+ file to add the other side of the association:

[source, ruby]
-------------------------------------------------------
class Post < ActiveRecord::Base
  validates_presence_of :name, :title
  validates_length_of :title, :minimum => 5
  has_many :comments
end
-------------------------------------------------------

These two declarations enable a good bit of automatic behavior. For example, if you have an instance variable +@post+ containing a post, you can retrieve all the comments belonging to that post as the array +@post.comments+.

TIP: For more information on Active Record associations, see the link:../association_basics.html[Active Record Associations] guide.

=== Adding a Route

_Routes_ are entries in the +config/routes.rb+ file that tell Rails how to match incoming HTTP requests to controller actions. Open up that file and find the existing line referring to +posts+. Then edit it as follows:

[source, ruby]
-------------------------------------------------------
map.resources :posts do |post|
  post.resources :comments
end
-------------------------------------------------------

This creates +comments+ as a _nested resource_ within +posts+. This is another part of capturing the hierarchical relationship that exists between posts and comments.

TIP: For more information on routing, see the link:../routing_outside_in.html[Rails Routing from the Outside In] guide.

=== Generating a Controller

With the model in hand, you can turn your attention to creating a matching controller. Again, there's a generator for this:

[source, shell]
-------------------------------------------------------
$ script/generate controller Comments index show new edit
-------------------------------------------------------

This creates seven files:

* +app/controllers/comments_controller.rb+ - The controller
* +app/helpers/comments_helper.rb+ - A view helper file
* +app/views/comments/index.html.erb+ - The view for the index action
* +app/views/comments/show.html.erb+ - The view for the show action
* +app/views/comments/new.html.erb+ - The view for the new action
* +app/views/comments/edit.html.erb+ - The view for the edit action
* +test/functional/comments_controller_test.rb+ - The functional tests for the controller

The controller will be generated with empty methods for each action that you specified in the call to +script/generate controller+:

[source, ruby]
-------------------------------------------------------
class CommentsController < ApplicationController
  def index
  end

  def show
  end

  def new
  end

  def edit
  end

end
-------------------------------------------------------

You'll need to flesh this out with code to actually process requests appropriately in each method. Here's a version that (for simplicity's sake) only responds to requests that require HTML:

[source, ruby]
-------------------------------------------------------
class CommentsController < ApplicationController
  def index
    @post = Post.find(params[:post_id])
    @comments = @post.comments
  end

  def show
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
  end

  def new
    @post = Post.find(params[:post_id])
    @comment = @post.comments.build
  end

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.build(params[:comment])
    if @comment.save
      redirect_to post_comment_url(@post, @comment)
    else
      render :action => "new"
    end
  end
  
  def edit
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
  end

  def update
    @post = Post.find(params[:post_id])
    @comment = Comment.find(params[:id])
    if @comment.update_attributes(params[:comment])
      redirect_to post_comment_url(@post, @comment)
    else
      render :action => "edit"
    end
  end
  
end
-------------------------------------------------------

You'll see a bit more complexity here than you did in the controller for posts. That's a side-effect of the nesting that you've set up; each request for a comment has to keep track of the post to which the comment is attached.

In addition, the code takes advantage of some of the methods available for an association. For example, in the +new+ method, it calls

[source, ruby]
-------------------------------------------------------
@comment = @post.comments.build
-------------------------------------------------------

This creates a new +Comment+ object _and_ sets up the +post_id+ field to have the +id+ from the specified +Post+ object in a single operation.

=== Building Views

Because you skipped scaffolding, you'll need to build views for comments "by hand." Invoking +script/generate controller+ will give you skeleton views, but they'll be devoid of actual content. Here's a first pass at fleshing out the comment views.

The +index.html.erb+ view:

[source, ruby]
-------------------------------------------------------
<h1>Comments for <%= @post.title %></h1>

<table>
  <tr>
    <th>Commenter</th>
    <th>Body</th>
  </tr>

<% for comment in @comments %>
  <tr>
    <td><%=h comment.commenter %></td>
    <td><%=h comment.body %></td>
    <td><%= link_to 'Show', post_comment_path(@post, comment) %></td>
    <td><%= link_to 'Edit', edit_post_comment_path(@post, comment) %></td>
    <td><%= link_to 'Destroy', post_comment_path(@post, comment), :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New comment', new_post_comment_path(@post) %>
<%= link_to 'Back to Post', @post %>
-------------------------------------------------------

The +new.html.erb+ view:

[source, ruby]
-------------------------------------------------------
<h1>New comment</h1>

<% form_for([@post, @comment]) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit "Create" %>
  </p>
<% end %>

<%= link_to 'Back', post_comments_path(@post) %>
-------------------------------------------------------

The +show.html.erb+ view:

[source, ruby]
-------------------------------------------------------
<h1>Comment on <%= @post.title %></h1>

<p>
  <b>Commenter:</b>
  <%=h @comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%=h @comment.body %>
</p>

<%= link_to 'Edit', edit_post_comment_path(@post, @comment) %> |
<%= link_to 'Back', post_comments_path(@post) %>
-------------------------------------------------------

The +edit.html.erb+ view:

[source, ruby]
-------------------------------------------------------
<h1>Editing comment</h1>

<% form_for([@post, @comment]) do |f| %>
  <%= f.error_messages %>

  <p>
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit "Update" %>
  </p>
<% end %>

<%= link_to 'Show', post_comment_path(@post, @comment) %> |
<%= link_to 'Back', post_comments_path(@post) %>
-------------------------------------------------------

Again, the added complexity here (compared to the views you saw for managing comments) comes from the necessity of juggling a post and its comments at the same time.

=== Hooking Comments to Posts

As a final step, I'll modify the +show.html.erb+ view for a post to show the comments on that post, and to allow managing those comments:

[source, ruby]
-------------------------------------------------------
<p>
  <b>Name:</b>
  <%=h @post.name %>
</p>

<p>
  <b>Title:</b>
  <%=h @post.title %>
</p>

<p>
  <b>Content:</b>
  <%=h @post.content %>
</p>

<h2>Comments</h2>
<% @post.comments.each do |c| %>
	<p>
	  <b>Commenter:</b>
	  <%=h c.commenter %>
	</p>

	<p>
	  <b>Comment:</b>
	  <%=h c.body %>
	</p>
<% end %>

<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
<%= link_to 'Manage Comments', post_comments_path(@post) %>
-------------------------------------------------------

Note that each post has its own individual comments collection, accessible as +@post.comments+. That's a consequence of the declarative associations in the models. Path helpers such as +post_comments_path+ come from the nested route declaration in +config/routes.rb+.

== What's Next?

Now that you've seen your first Rails application, you should feel free to update it and experiment on your own. But you don't have to do everything without help. As you need assistance getting up and running with Rails, feel free to consult these support resources:

* The link:http://guides.rubyonrails.org/[Ruby On Rails guides]
* The link:http://groups.google.com/group/rubyonrails-talk[Ruby on Rails mailing list]
* The #rubyonrails channel on irc.freenode.net
* The link:http://wiki.rubyonrails.org/rails[Rails wiki]

Rails also comes with built-in help that you can generate using the rake command-line utility:

* Running +rake doc:guides+ will put a full copy of the Rails Guides in the +/doc/guides+ folder of your application. Open +/doc/guides/index.html+ in your web browser to explore the Guides.
* Running +rake doc:rails+ will put a full copy of the API documentation for Rails in the +/doc/api+ folder of your application. Open +/doc/api/index.html+ in your web browser to explore the API documentation.

== Changelog ==

http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/2[Lighthouse ticket]

* November 3, 2008: Formatting patch from Dave Rothlisberger
* November 1, 2008: First approved version by link:../authors.html#mgunderloy[Mike Gunderloy]
* October 16, 2008: Revised based on feedback from Pratik Naik by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* October 13, 2008: First complete draft by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* October 12, 2008: More detail, rearrangement, editing by link:../authors.html#mgunderloy[Mike Gunderloy] (not yet approved for publication)
* September 8, 2008: initial version by James Miller (not yet approved for publication)















